<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  
  <link rel="shortcut icon" href="../../img/favicon.ico">
  <title>《算法导论》阅读笔记 - Huang Hao's Blog</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="../../css/theme.css" />
  <link rel="stylesheet" href="../../css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "\u300a\u7b97\u6cd5\u5bfc\u8bba\u300b\u9605\u8bfb\u7b14\u8bb0";
    var mkdocs_page_input_path = "\u7b97\u6cd5\u57fa\u7840\\\u300a\u7b97\u6cd5\u5bfc\u8bba\u300b\u9605\u8bfb\u7b14\u8bb0.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../../js/jquery-2.1.1.min.js" defer></script>
  <script src="../../js/modernizr-2.8.3.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href="../.." class="icon icon-home"> Huang Hao's Blog</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../..">Huang Hao' Blog</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Paper Readings</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../Paper%20Readings/%E3%80%8AA%20Survey%20of%20Learning%20Causality%20with%20Data%20Problems%20and%20Methods%E3%80%8B/">《A Survey of Learning Causality with Data: Problems and Methods》阅读笔记</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../Paper%20Readings/%E3%80%8AStructure%20Learning%20of%20Bayesian%20Networks%20by%20Genetic%20Algorithms%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">《Structure Learning of Bayesian Networks by Genetic Algorithms》阅读笔记</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../Paper%20Readings/%E3%80%8Aattention%20is%20all%20your%20need%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">《attention is all your need》阅读笔记</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">算法基础</span></p>
                <ul class="current">
                    <li class="toctree-l1"><a class="reference internal" href="../python%E7%9A%84%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/">python的语言特性</a>
                    </li>
                    <li class="toctree-l1 current"><a class="reference internal current" href="./">《算法导论》阅读笔记</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#_2">第一章 算法在计算中的作用</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#_3">作为一种技术的算法</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_4">算法的重要性</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#_5">比较插入排序与并归排序</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_6">第二章 算法基础</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#_7">插入排序</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_8">分析算法</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_9">设计算法</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#_10">分治法</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#_11">分析分治算法</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_12">第三章 函数的增长</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#_13">渐近记号</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_14">标准记号与常用函数</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_15">第四章 分治策略</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#_16">递归式</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_17">最大数组问题</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#strassen">矩阵乘法的Strassen算法</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_18">求解递归式</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_19">第五章 概率分析和随机算法</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#_20">雇佣问题</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_21">指示器随机变量</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_22">随机算法</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#knuth">Knuth洗牌算法</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_23">第六章 堆排序</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#_24">堆</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_25">维持最大堆</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_26">建堆</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_27">堆排序</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_28">优先队列</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_29">第七章 快速排序</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#_30">快速排序的性能分析</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_31">快速排序的随机化版本</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_32">第八章 线性时间排序</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#_33">排序算法的下界</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_34">最坏情况的下界</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_35">计数排序</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_36">基数排序</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_37">桶排序</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_38">第九章 中位数和顺序统计量</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#_39">最小值和最大值</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_40">期望为线性时间的选择算法</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_41">第十章 基本数据结构</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#_42">栈和队列</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_43">链表</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_44">有根树</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#_45">二叉树</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#_46">分支无限制的有根树</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_47">第十一章 散列表</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_48">第十二章 二叉搜索树</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#_49">中序遍历、前序遍历，后序遍历</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_50">第十五章 动态规划</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#_51">设计方法</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_52">自下而上的一维数组</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#_53">钢管切割</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_54">自下而上的二维数组</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#_55">矩阵链乘</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#_56">最长公共子序列</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_57">最优二叉搜索树</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_58">自上而下的备忘录机制</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_59">第二十二章 图算法</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#_60">例题</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_61">广度优先搜索</a>
    </li>
        </ul>
    </li>
    </ul>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../%E5%8A%9B%E6%89%A3%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/">力扣题目总结</a>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../..">Huang Hao's Blog</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../..">Docs</a> &raquo;</li>
    
      
        
          <li>算法基础 &raquo;</li>
        
      
    
    <li>《算法导论》阅读笔记</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  
  <hr/>
</div>

          <div role="main">
            <div class="section">
              
                <h1 id="_1">《算法导论》阅读笔记</h1>
<p>开始于2021年3月3日  黄浩</p>
<p>答案：https://walkccc.me/CLRS/</p>
<h2 id="_2">第一章 算法在计算中的作用</h2>
<p>算法algorithm描述一个特定的计算过程来实现输入和输出的关系</p>
<ul>
<li>算法问题的两个特征：</li>
</ul>
<p>存在许多候选解，寻找一个真正的解或者一个最好的解可能是一个很大的挑战；</p>
<p>存在实际应用。</p>
<ul>
<li>数据结构</li>
</ul>
<p>数据结构是数据的储存和组织方式，旨在方便访问与修改</p>
<ul>
<li>技术</li>
</ul>
<p>本书有一些特定的问题解决方法</p>
<ul>
<li>难题</li>
</ul>
<p>一部分问题，目前不知道有效的方法，被称为<strong>NP完全的</strong>。请参照第34章学习NP完全性。</p>
<p>特点：1. 对于NP完全问题，目前没有找到有效的算法，但是也没人能证明NP完全的问题确实不存在有效算法。</p>
<p>​           2. 如果NP完全问题被解决，那么一系列的NP完全问题都会被解决</p>
<p>“旅行商问题”，NP完全问题一般寻求近似算法。</p>
<ul>
<li>并行性</li>
</ul>
<h3 id="_3">作为一种技术的算法</h3>
<p>计算机有两个限制：速度与储存</p>
<p>指令/速度 = 时间</p>
<p>指令数目与算法与编译器有关</p>
<p>速度与计算机速度有关。</p>
<h3 id="_4">算法的重要性</h3>
<h4 id="_5">比较插入排序与并归排序</h4>
<p>比较插入顺序与归并顺序在相同机器上的实现。输入规模为n，插入排序运行8n^2步，而并归排序运行64n lgn 步，问对于哪些n值，插入排序优于归并排序</p>
<p><img src="%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210303150617358-16478516959433.png" alt="image-20210303150617358" style="zoom:50%;" /></p>
<p>n取2，3，4，5，6。</p>
<h2 id="_6">第二章 算法基础</h2>
<h3 id="_7">插入排序</h3>
<pre><code class="language-python">def insertion_sort(A):
    for j in range(1,len(A)):
        key = A[j]
        i = j - 1
        while i &gt;= 0 and A[i] &gt; key:
            A[i+1] = A[i]
            i -= 1
        a[i+1] = key
</code></pre>
<p>注意边界条件，以及<strong>循环不变式</strong>：A[:j]是排序好了的，比如 j=1的时候，A[0]一个元素就是排序好了的。</p>
<p>插入排序适用于少量元素的排序。</p>
<p><img alt="image-20210303152602643" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210303152602643.png" /></p>
<p><img alt="image-20210303160204515" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210303160204515.png" /></p>
<p>这是一个$O(n^2)$的算法。</p>
<h3 id="_8">分析算法</h3>
<p><strong>插入排序算法的分析</strong></p>
<p>输入规模</p>
<p>运行时间，指执行的基本操作数或步数</p>
<p><img alt="image-20210304143251776" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210304143251776.png" /></p>
<p>得到运行时间为：</p>
<p><img alt="image-20210304143319906" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210304143319906.png" /></p>
<p>最佳情况，就是输入的就是个已经排序拍好的：</p>
<p><img alt="image-20210304143426145" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210304143426145.png" /></p>
<p>最坏情况，输入是相反排序的：</p>
<p><img alt="image-20210304143829191" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210304143829191.png" /></p>
<p><strong>最坏情况</strong></p>
<p><strong>平均情况分析</strong></p>
<p><strong>增长量级</strong></p>
<p>使用一些简化抽象，比如忽略上文中的c，即每个指令的时间，而关注最重要的项。对于足够大的输入，最高阶项起最大作用。</p>
<p><img alt="image-20210304144146839" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210304144146839.png" /></p>
<p>练习题:</p>
<p><img alt="image-20210304152809107" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210304152809107.png" /></p>
<h3 id="_9">设计算法</h3>
<p>插入排序采用  了增量的方法：在排序好前 1--j-1个元素以后，再将当个j元素插入到子数组的适当位置，产生排序好的子数组 i--j</p>
<h4 id="_10">分治法</h4>
<p>分治法的思想：将原问题分解为几个规模较小但类似于原问题的子问题，递归地求解这些子问题、</p>
<p>分治的模式：</p>
<ul>
<li>分解</li>
<li>解决这些子问题</li>
<li>合并</li>
</ul>
<p><strong>归并排序算法</strong>完全遵循分治模式</p>
<p><img alt="image-20210304153549414" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210304153549414.png" /></p>
<p>合并函数 merge：</p>
<p>输入数组，p，q，r，分成两段，将两组进行合并</p>
<p><img alt="image-20210308113200348" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210308113200348.png" /></p>
<p><img alt="image-20210308113212314" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210308113212314.png" /></p>
<p>将merge作为归并排序算法中的一个子程序来用：</p>
<p><img alt="image-20210308113301295" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210308113301295.png" /></p>
<pre><code class="language-python">def merge_sort(A,p,r):

    def merge(A,p,r,q):
        pass

    if p&lt;r:
        q = int((r-p)/2)
        merge_sort(A,p,q)
        merge_sort(A,q,r)
        merge(A,p,q,r)

</code></pre>
<h4 id="_11">分析分治算法</h4>
<p><img alt="image-20210308113515500" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210308113515500.png" /></p>
<p><strong>并归排序算法的分析</strong></p>
<p><img alt="image-20210308113646493" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210308113646493.png" /></p>
<p>忽略低阶项和常数c便给出期望的结果O(nlgn) </p>
<p><strong>思考题</strong></p>
<p><img alt="image-20210308154006629" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210308154006629.png" /></p>
<p>冒泡排序的最坏情况运行 O(n^2^)，插入排序的最坏运行也是O(n^2^)</p>
<p><img alt="image-20210308160343847" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210308160343847.png" /></p>
<p>b. n-1 + ... +1 = n(n-1)/2 个 </p>
<h2 id="_12">第三章 函数的增长</h2>
<p>算法运行时间的增长量级简单地刻画了算法的效率。</p>
<p>当输入规模n变得足够大，最坏运行时间为$\Theta(n \lg n)$ 的并归排序将战胜插入排序$\Theta\left(n^{2}\right)$</p>
<h3 id="_13">渐近记号</h3>
<p>$\Theta$记号</p>
<p><img alt="image-20210309154546108" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210309154546108.png" /></p>
<p><img alt="image-20210309154601231" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210309154601231.png" /></p>
<p>$O$ 记号：渐近上界</p>
<p>$\Omega$记号：渐近下界</p>
<p>各种渐近关系符合：传递性，自反性，对称性，转置对称性，三分性</p>
<h3 id="_14">标准记号与常用函数</h3>
<ul>
<li>单调性</li>
<li>向下取整与向上取整</li>
<li>模运算</li>
<li>多项式</li>
<li>指数</li>
<li>对数</li>
<li>阶乘</li>
<li>多重函数</li>
<li>多重对数函数</li>
<li>斐波那契数</li>
<li><img alt="image-20210309163840558" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210309163840558.png" /></li>
</ul>
<p><img alt="image-20210309154910032" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210309154910032.png" /></p>
<h2 id="_15">第四章 分治策略</h2>
<p>分治的策略中，我们使用递归来解决问题。</p>
<p>三个核心：</p>
<ol>
<li>分解为子问题</li>
<li>解决，也可以理解为终止条件</li>
<li>合并</li>
</ol>
<h3 id="_16">递归式</h3>
<p>分治的规模对分治法的性能影响很大。</p>
<p>例如对半分（分治排序）：</p>
<p><img alt="image-20220315161441624" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20220315161441624.png" /></p>
<p>还可以1/3,2/3分</p>
<p>减少一个元素分：</p>
<p><img alt="image-20220315161528006" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20220315161528006.png" /></p>
<p>**不同的递归式，其复杂度也大不相同！</p>
<p>当子问题足够大需要递归求解时，我们称之为<strong>递归情况</strong></p>
<p>当子问题足够小，不再需要递归时，说明递归已经触底，进入了<strong>基本情况</strong></p>
<p>递归式：</p>
<p><img alt="image-20210310140240348" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210310140240348.png" /></p>
<p>求解可得：</p>
<p><img alt="image-20210310140301895" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210310140301895.png" /></p>
<p>求解递归式的方法：代入法，递归树法，主方法。</p>
<h3 id="_17">最大数组问题</h3>
<p><img alt="image-20210310151258397" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210310151258397.png" /></p>
<ul>
<li>暴力求解法</li>
<li>问题变换</li>
<li>使用分治策略的求解法</li>
</ul>
<p>使用分治算法的复杂度为</p>
<p><img alt="image-20210310163759716" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210310163759716.png" /></p>
<p><strong>练习</strong></p>
<p><img alt="image-20210310163824523" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210310163824523-16478513544691.png" /></p>
<p><img alt="comparison between Divide-and-Conquer and Traversal Algorithm" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/comparison%20between%20Divide-and-Conquer%20and%20Traversal%20Algorithm.PNG" /></p>
<p><img alt="image-20210310184325798" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210310184325798.png" /></p>
<p>这道题需要采用动态规划的办法解决。<strong>尚未解决</strong></p>
<h3 id="strassen">矩阵乘法的Strassen算法</h3>
<p><img alt="image-20210310184928910" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210310184928910.png" /></p>
<p><img alt="image-20210310184941419" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210310184941419.png" /></p>
<p>时间复杂度为$\Theta\left(n^{3}\right)$，但是Strassen的著名n*n矩阵相乘的递归算法，复杂度为$\Theta\left(n^{\lg 7}\right)$，其中lg7约为2.8和2.81。</p>
<p>递归算法时间复杂度也是时间复杂度为$\Theta\left(n^{3}\right)$。</p>
<p><img alt="image-20210311153047731" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210311153047731.png" /></p>
<p><img alt="image-20210311153323685" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210311153323685.png" /></p>
<p>其中$\Theta(1)$ 是分解A,B,C矩阵。$\Theta\left(n^{2}\right)$ 是元素相加。</p>
<p>注意8T(n/2)中的8决定了递归树是否茂盛，不能省略，否则就是线性结构了。</p>
<p><strong>Strassen算法</strong></p>
<p>其核心思想就是将8T(n/2)改为7T(n/2)</p>
<p>伪代码（自写）：</p>
<pre><code class="language-伪代码">def Strassen(a,b):
    n = a的维度
    c = n*n matrix
    if n == 1:
        c11 = a11*b11
    else:
        s1 = b12-b22
        s2 = a11+a12
        s3 = a21+a22
        s4 = b21-b11
        s5 = a11+a22
        s6 = b11+b22
        s7 = a12-a22
        s8 = b21+b22
        s9 = a11-a21
        s10 = b11+b12
        p1 = Strassen(a11,s1)
        p2
        p3
        p4
        p5
        p6
        p7
        c11 = 
        c12
        c21
        c22
    return c    
</code></pre>
<p>练习：</p>
<p><img alt="image-20210312134101025" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210312134101025.png" /></p>
<h3 id="_18">求解递归式</h3>
<p><strong>代入法</strong>，它主要分为两步：</p>
<ol>
<li>猜测解的形式</li>
<li>用数学归纳法求出解的常数，并证明解是正确的</li>
</ol>
<p><img alt="image-20210312135112388" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210312135112388.png" /></p>
<ul>
<li>猜测：</li>
</ul>
<p>上界为：</p>
<p><img alt="image-20210312135138868" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210312135138868.png" /></p>
<ul>
<li>要求证明：</li>
</ul>
<p><img alt="image-20210312135431289" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210312135431289.png" /></p>
<p><img alt="image-20210312135600561" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210312135600561.png" /></p>
<p><strong>递归树</strong></p>
<p>例如：</p>
<p><img alt="image-20210312135659962" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210312135659962.png" /></p>
<p><img alt="image-20210312135710128" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210312135710128.png" /></p>
<p><img alt="image-20210312135923836" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210312135923836.png" /></p>
<p><img alt="image-20210312140214317" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210312140214317.png" /></p>
<p><strong>主方法</strong></p>
<p>（略）</p>
<h2 id="_19">第五章 概率分析和随机算法</h2>
<h3 id="_20">雇佣问题</h3>
<p><img alt="image-20210312143526161" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210312143526161.png" /></p>
<p>伪代码：</p>
<p><img alt="image-20210312143545103" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210312143545103.png" /></p>
<p>最坏情形分析</p>
<p><img alt="image-20210312144552178" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210312144552178.png" /></p>
<p><strong>随机算法</strong></p>
<p>为了利用概率分析，需要了解关于输入分布的一些信息。</p>
<h3 id="_21">指示器随机变量</h3>
<p><img alt="image-20210312160323249" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210312160323249.png" /></p>
<p><img alt="image-20210312161021096" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210312161021096.png" /></p>
<h3 id="_22">随机算法</h3>
<p>如何理解随机排序，一个公平的算法能够均匀地给出n！个结果中的一个。但是如果这样的话，算法需要给出n！个选择，它的复杂度太高O(n!)，随机算法应运而生。</p>
<p>随机排列数组：</p>
<p><img alt="image-20210312165243306" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210312165243306.png" /></p>
<p>P表示的是优先级：假设优先级都不同，则算法产生输入的均匀随机排列。</p>
<p><img alt="image-20210312171354302" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210312171354302.png" /></p>
<p><strong>小tip：</strong></p>
<p><img alt="image-20210312204458308" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210312204458308.png" /></p>
<h3 id="knuth">Knuth洗牌算法</h3>
<p><img alt="image-20210312204550250" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210312204550250.png" /></p>
<p><img alt="img" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/v2-1b4e619875fa6eed722fc0fcd30f4131_720w.jpg" /></p>
<p><img alt="img" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/v2-1c7f79a322e8a9687eaaa648863efb0d_720w.jpg" /></p>
<p><img alt="img" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/v2-d930f1a8f34c2a5056fa58048ad762e8_720w.jpg" /></p>
<p><img alt="img" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/v2-fe5a19b92bf338722a35c017ad75127a_720w.jpg" /></p>
<p><img alt="img" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/v2-90f4110c3954039a95995834021ad4f0_720w.jpg" /></p>
<p><img alt="img" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/v2-c69895a774b2ff22d03220aaec22ff3a_720w.jpg" /></p>
<p><img alt="img" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/v2-9de51683f0df5707cda76b9ea784f1df_720w.jpg" /></p>
<p><img alt="img" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/v2-d89b5143bce1f4580a77b5a384e475d8_720w.jpg" /></p>
<p>排序问题：</p>
<p><img alt="image-20210312205328951" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210312205328951.png" /></p>
<p><strong>排序算法：</strong></p>
<p>插入排序，$\Theta\left(n^{2}\right)$，他是原址的（仅有常数项个元素需要储存在数组之外），对于小规模排序，插入排序非常适用。</p>
<p>归并算法，$\Theta(n \lg n)$，它的merge函数并不是原址的，但他有更好的渐进时间。</p>
<p>在下文中 第六场介绍堆排序，第七章介绍快速排序。</p>
<p><img alt="image-20210312205929251" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210312205929251.png" /></p>
<h2 id="_23">第六章 堆排序</h2>
<p><strong>它融合了快速排序和归并排序的优点</strong></p>
<p>利用堆的数据结构，结合了插入排序和归并排序的优点：复杂度$\Theta(n \lg n)$，具有原址性。</p>
<h3 id="_24">堆</h3>
<p><strong>堆是一个数组，一个近似的完全二叉树</strong></p>
<p><img alt="image-20210312213952774" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210312213952774.png" /></p>
<p>计算位置：</p>
<p><img src="%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210312214009810.png" alt="image-20210312214009810" style="zoom: 67%;" /></p>
<p>最大堆，最小堆。最大堆就是最大的节点在最上面的根节点。</p>
<p>最大堆的一些性质：</p>
<ol>
<li>最大堆的最大值在根节点上，在python中，一般使用最小堆，根节点是最小值</li>
<li>构造最大堆，线性复杂度</li>
<li>维护最大堆，复杂度为 $O(lgn)$，只能</li>
<li>堆排序  $O(nlgn)$</li>
</ol>
<p><img alt="image-20210312215219362" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210312215219362.png" /></p>
<p><img alt="image-20210312215242027" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210312215242027.png" /></p>
<h3 id="_25">维持最大堆</h3>
<p><img alt="image-20210312222646875" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210312222646875.png" /></p>
<p><img alt="image-20210312222709066" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210312222709066.png" /></p>
<p>复杂度：O(lgn)</p>
<p>维护最大堆：就是把第i个元素和两个孩子做对比，与孩子中的较大值进行交换。</p>
<h3 id="_26">建堆</h3>
<p>自底向上建造最大堆。</p>
<p>数学归纳可知: (n-1)//2+1 到 n 均为 叶子，那么（n-1）//2 为非叶子，所以对这些进行最大堆维护即可</p>
<p><img alt="image-20210317202340578" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210317202340578.png" /></p>
<h3 id="_27">堆排序</h3>
<p><img alt="image-20210317213835349" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210317213835349.png" /></p>
<p><strong>需要一定的数学证明：堆排序的时间复杂度为nlogn</strong></p>
<p><img alt="image-20210317213925271" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210317213925271.png" /></p>
<h3 id="_28">优先队列</h3>
<p>用最大堆实现最大优先队列</p>
<p>优先队列的每一个元素都有一个相关的值，称为关键字KEY，最大优先队列支持以下操作：</p>
<p>insert(s,x):把元素插入到集合x中</p>
<p>maximum(s):返回s中最大元素</p>
<p>extract-max(s):去掉并返回s中具有最大关键字的元素</p>
<p>increase-key(s,x,k):将元素x的关键字值增加到k，假设k值不小于原来的关键字值</p>
<p>** 插入就直接在数组后方加入，然后注意维护堆即可</p>
<p><img alt="image-20210317223233076" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210317223233076.png" /></p>
<p><img alt="image-20210317223334639" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210317223334639.png" /></p>
<p><img alt="image-20210317223347158" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210317223347158.png" /></p>
<p><img alt="image-20210317223358182" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210317223358182.png" /></p>
<p>先改变A[i]的值，然后在‘’原有的最大堆‘’上维护最大堆。</p>
<p><img alt="image-20210317223530607" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210317223530607.png" /></p>
<h2 id="_29">第七章 快速排序</h2>
<p>快速排序是实际排序应用中的最好选择，它的平均性能最好，期望时间复杂度还是$\Theta(n \lg n)$，但是隐含的常数因子非常小，他也能进行原址排序，甚至虚拟环境中也能很好地工作。</p>
<p><strong>分治的思想</strong></p>
<p><img alt="image-20210318110659609" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210318110659609.png" /></p>
<p>算法可以基于原址，所以不需要归并，只需要做好分割即可。</p>
<p><strong>分割函数</strong></p>
<p><img alt="image-20210318113111431" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210318113111431.png" /></p>
<p><img alt="image-20210318121732644" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210318121732644.png" /></p>
<h3 id="_30">快速排序的性能分析</h3>
<p><strong>最坏情况划分</strong></p>
<p>如果每次划分都包含了n-1和1个元素，那是最差的情况，划分操作复杂度为n</p>
<p><img alt="image-20210318122456549" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210318122456549.png" /></p>
<p>复杂度结果为：$\Theta\left(n^{2}\right)$</p>
<p><strong>最好情况划分</strong></p>
<p><img alt="image-20210318123622903" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210318123622903.png" /></p>
<p>复杂度结果为$\Theta(n \lg n)$</p>
<p><strong>平衡的划分</strong></p>
<p>快速排序的平均运行时间更接近于其最好情况，并非最坏情况</p>
<p>（个人理解：每次划分，都分到到最差情况的概率是非常小的）</p>
<h3 id="_31">快速排序的随机化版本</h3>
<p>主要修改是将主元素随机选取</p>
<p><img alt="image-20210318124141954" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210318124141954.png" /></p>
<table>
<thead>
<tr>
<th>插入排序</th>
<th>插入扑克牌式</th>
</tr>
</thead>
<tbody>
<tr>
<td>归并排序</td>
<td>分治</td>
</tr>
<tr>
<td>堆排序</td>
<td>最大堆的维护始终能找到最大的元素</td>
</tr>
<tr>
<td>快速排序</td>
<td>分割</td>
</tr>
</tbody>
</table>
<h2 id="_32">第八章 线性时间排序</h2>
<p>之前提到的算法都有一个性质：在排序的最终结果中，个元素的次序依赖于它们之间的比较。<strong>比较排序</strong></p>
<h3 id="_33">排序算法的下界</h3>
<p>决策树模型---完全二叉树</p>
<p><img src="%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210318212924801.png" alt="image-20210318212924801" style="zoom:67%;" /></p>
<p>叶节点共有n！种可能的排列。</p>
<h3 id="_34">最坏情况的下界</h3>
<p>排序算法最坏情况就是决策树的高度</p>
<p>定理：</p>
<ul>
<li>
<p>最坏情况下，任何比较排序算法都需要$\Omega(n \lg n)$次比较</p>
</li>
<li>
<p>堆排序和归并排序都是渐进最优的排序算法</p>
</li>
</ul>
<p><img alt="image-20210319172828413" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210319172828413.png" /></p>
<h3 id="_35">计数排序</h3>
<p><img alt="image-20210319174054532" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210319174054532.png" /></p>
<p>图解：</p>
<p><img alt="image-20210319174124617" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210319174124617.png" /></p>
<p>运行时间为：$\Theta(n)$</p>
<p>计数排序的一个重要性质就是<strong>稳定</strong>，对于相同值的元素在输出数组中的相对次序与他们在输入数组中的次序相同，这种稳定性在当有数据附带卫星数据时比较重要。</p>
<p><img alt="image-20210319174502412" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210319174502412.png" /></p>
<h3 id="_36">基数排序</h3>
<p><img alt="image-20210322125301733" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210322125301733-16478515658861.png" /></p>
<p>伪代码：</p>
<p><img alt="image-20210322125320869" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210322125320869.png" /></p>
<p>引理：</p>
<p>采用稳定排序方法，比如计数排序：$\Theta(d(n+k))$ ，即运行d次计数排序。</p>
<p><strong>基数排序是否比基于比较的排序算法更好呢？</strong></p>
<p>基数排序虽然执行的循环轮数会比快速排序少，但是每一轮它所耗费的时间要长的多，哪一种排序合适更依赖于具体实现和底层的特性，比如快速排序通常比基数排序更有效地使用硬件的缓存。</p>
<p><img alt="image-20210322164126997" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210322164126997.png" /></p>
<h3 id="_37">桶排序</h3>
<p>桶排序假设输入数据服从均匀分布，平均情况下它的时间代价为$O(n)$。</p>
<p><img alt="image-20210322152251746" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210322152251746.png" /></p>
<p><img alt="image-20210322152306518" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210322152306518.png" /></p>
<h2 id="_38">第九章 中位数和顺序统计量</h2>
<p>order statistic 第i个顺序统计量是该集合中第i个元素</p>
<p>最大值 i = n</p>
<p>最小值 n = 1</p>
<p>n为偶数时存在两个中位数，下中位数/上中位数</p>
<h3 id="_39">最小值和最大值</h3>
<p><img alt="image-20210324134833603" src="../%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210324134833603-16478515730862.png" /></p>
<p>经过n-1次比较找出最大值或最小值。</p>
<h3 id="_40">期望为线性时间的选择算法</h3>
<p>选择数组中第i小的元素</p>
<p><img alt="image-20210324140105770" src="%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0.assets/image-20210324140105770.png" /></p>
<p>此处的partition是快速排序的分割（分成三段，第一段小于key，第二段为key，第三段大于key）</p>
<h2 id="_41">第十章 基本数据结构</h2>
<p>栈，队列，链表，有根树。</p>
<h3 id="_42">栈和队列</h3>
<p>栈和队列都是动态集合，在其上进行delete操作是预定的：</p>
<p>栈：后进先出</p>
<p>队列：先进先出</p>
<p><strong>栈</strong></p>
<p>insert操作被称为压入push</p>
<p>delete操作被称为弹出pop</p>
<p><img alt="image-20210324142310388" src="%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0.assets/image-20210324142310388.png" /></p>
<p><strong>队列</strong></p>
<p>insert: enqueue</p>
<p>delete: dequeue </p>
<p><img alt="image-20210324142758700" src="%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0.assets/image-20210324142758700.png" /></p>
<h3 id="_43">链表</h3>
<p>双向链表</p>
<p>prev - element - next</p>
<p><img alt="image-20210324142917842" src="%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0.assets/image-20210324142917842.png" /></p>
<p><strong>哨兵</strong></p>
<p><img alt="image-20210324143837463" src="%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0.assets/image-20210324143837463.png" /></p>
<p>L.nil 的next 指向第一个元素（表头）</p>
<p>L.nil的prev 指向最后一个元素（表尾）</p>
<p>所以此处不需要L.head</p>
<p>只需要L.nil.next</p>
<h3 id="_44">有根树</h3>
<p>树可以分为多种树，二叉树，分支无限制的有根树。。。等等</p>
<h4 id="_45">二叉树</h4>
<p><img alt="image-20220315174746798" src="%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0.assets/image-20220315174746798.png" /></p>
<h4 id="_46">分支无限制的有根树</h4>
<p><img alt="image-20220315174807252" src="%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0.assets/image-20220315174807252.png" /></p>
<h2 id="_47">第十一章 散列表</h2>
<p>待完成。。。</p>
<h2 id="_48">第十二章 二叉搜索树</h2>
<p><img alt="image-20220315175149485" src="%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0.assets/image-20220315175149485.png" /></p>
<h4 id="_49">中序遍历、前序遍历，后序遍历</h4>
<p>采用<strong>递归</strong>的方式进行遍历，也可以用<strong>栈</strong>。 </p>
<p>上面的树的中序遍历为</p>
<p>2，5，5，6，7，8</p>
<blockquote>
<p>如果想一层层的遍历，采用广度优先搜索，借用队列</p>
</blockquote>
<h2 id="_50">第十五章 动态规划</h2>
<p>dynamic programming 动态规划</p>
<p>特征：</p>
<ol>
<li>找的是最优解。</li>
<li>最优子结构：最优解=f(最优子结构)</li>
<li>重叠子问题：当处理子问题的时候，会遇到重复的情况，所以归并排序并不属于动态规划。</li>
</ol>
<p>两种实现方法：</p>
<ol>
<li>自上而下：采用备忘录的方式</li>
<li>自下而上：构建表格，也称为的dp数组</li>
</ol>
<h3 id="_51">设计方法</h3>
<ol>
<li>写出递归函数\贝尔曼方程\最优解的结构特征</li>
<li>计算最优解的值，通常采用自底向上的方法</li>
</ol>
<h3 id="_52">自下而上的一维数组</h3>
<h4 id="_53">钢管切割</h4>
<p><img alt="image-20220316141256924" src="%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0.assets/image-20220316141256924.png" /></p>
<ol>
<li>找最优解</li>
<li>存在最优子结构</li>
</ol>
<blockquote>
<p>此时已经可以采用递归的方式进行求解了，递归复杂度太高了，指数级</p>
</blockquote>
<pre><code>        3. 发现重叠子结构
        3. 动态规划！
        3. 选择：自上而下，或者**自下而上**
</code></pre>
<p>首先写出递归公式：
$$
r_n = max[p_1+r_{n-1}, p_2+r_{n-2},...,p_n]
$$
递归公式，左边由多个值计算而来，
$$
r_1 = p_1 \
r_2 = r_1 + p_1 或 p_2 \
r_3 = r_1 + p_2 或 r_2+ p_1 或 p_3<br />
$$
可以看到，r就是通过前面的数算出来的，就构建数组，初始化$r_1$ ，开始向上计算。</p>
<h3 id="_54">自下而上的二维数组</h3>
<p>对于一维问题
$$
f(0:n) = a+f(1:n)
$$
二维问题：
$$
f(0:n)=f(0:k)+f(k:n)
$$</p>
<h4 id="_55">矩阵链乘</h4>
<p><img alt="image-20220316144301160" src="%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0.assets/image-20220316144301160.png" /></p>
<p><img alt="image-20220316144233829" src="%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0.assets/image-20220316144233829.png" /></p>
<p>找最优化方案，明确这是一个最优化问题。</p>
<p>写递归方程：</p>
<p><img alt="image-20220316144724318" src="%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0.assets/image-20220316144724318.png" /></p>
<p>m表是dp表</p>
<p>s表用于记录最佳分割位置k</p>
<p><img alt="image-20220316145151893" src="%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0.assets/image-20220316145151893.png" /></p>
<h4 id="_56">最长公共子序列</h4>
<p><img alt="image-20220316151838506" src="%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0.assets/image-20220316151838506.png" /></p>
<ol>
<li>刻画最长公共子序列的特征</li>
<li>X有$2^m$个子序列，全部遍历一边，可以找到最长的</li>
</ol>
<p><img alt="image-20220316152556809" src="%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0.assets/image-20220316152556809.png" /></p>
<h3 id="_57">最优二叉搜索树</h3>
<p>涉及概率，有点难，待完善。</p>
<h3 id="_58">自上而下的备忘录机制</h3>
<h2 id="_59">第二十二章 图算法</h2>
<p>图的表示：</p>
<ul>
<li>邻接链表</li>
</ul>
<p>在表示稀疏图的时候非常适用</p>
<ul>
<li>邻接矩阵</li>
</ul>
<p>表示稠密图适用，可以快速判断两个节点是否存在边</p>
<p><img alt="image-20210314204153547" src="%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0.assets/image-20210314204153547.png" /></p>
<p>无论是有向图还是无向图，邻接链表的储存空间需求为：$\Theta(V+E)$</p>
<p>邻接链表稍加修改即可表示<strong>权重图</strong>，不足在于不能快速判断是否存在某个边，要去搜索。</p>
<p>邻接矩阵可以快速判断是否存在某个边，但是储存空间较大。需求为：$\Theta\left(V^{2}\right)$</p>
<p>无向图是对称的，可以节约一半的空间。</p>
<p><img alt="image-20210324145908829" src="%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0.assets/image-20210324145908829.png" /></p>
<h4 id="_60">例题</h4>
<p><img alt="image-20220316001430885" src="%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0.assets/image-20220316001430885.png" /></p>
<p>对于邻接链表来说：</p>
<p>遍历每个结点，每个节点的边进行翻转</p>
<p>邻接矩阵</p>
<p>上下三角对换。</p>
<p><img alt="image-20220316002001917" src="%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0.assets/image-20220316002001917.png" /></p>
<p>有向无环图</p>
<h3 id="_61">广度优先搜索</h3>
<p>该算法能够计算节点s到每个可到达的结点的距离（最少的边数），同时生成一颗广度优先搜索树。</p>
<p>s -- v的最短路径。</p>
<p><img alt="image-20210324151347032" src="%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0.assets/image-20210324151347032.png" /></p>
<p><img alt="image-20210324151358412" src="%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0.assets/image-20210324151358412.png" /></p>
<p><img alt="image-20210324151413034" src="%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0.assets/image-20210324151413034.png" /></p>
<p>先找出灰色</p>
<p>灰色中选择一个变黑，变黑元素周围变灰</p>
<p>再找出灰色</p>
<p>如此反复。</p>
<p>https://www.redblobgames.com/pathfinding/a-star/introduction.html </p>
<p>可以参考学习</p>
<p><strong>最短路径</strong></p>
<p>广度优先搜索可以计算出最短路径。</p>
<p><strong>最短路径距离的一些性质</strong></p>
<p><img alt="image-20210329154704023" src="%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0.assets/image-20210329154704023.png" /></p>
<h1 id="_62">问题，自测</h1>
<h2 id="_63">描述归并排序</h2>
<h2 id="_64">证明归并排序的时间复杂度</h2>
<p>画图、数学归纳法</p>
<h2 id="_65">二分查找描述，复杂度</h2>
<h2 id="xnlogn">描述一个算法，数组中找和为x的元素对，nlogn</h2>
<p>归并法</p>
<h2 id="_66">逆序对</h2>
<p>归并法</p>
<h2 id="random01randomabab">如果只能调用random(0,1)，如何做到random(a,b),返回ab之间的整数、</h2>
<p>首先，random(0,1)是随机的产生0,1两个整数，random(a,b)是随机产生[a,b]之间的整数。</p>
<p>实际上要随机生成一个 [0,b-a]的数，最后加上a。</p>
<p>为了生成这个数，那就要生成2进制数，bits，通过random(0,1）生成的二进制数都是等概率的。</p>
<p>所以逻辑就是，用random(0,1)生成一个二进制数</p>
<pre><code>RANDOM(a, b)
    range = b - a
    bits = ceil(log(2, range))
    result = 0
    for i = 0 to bits - 1
        r = RANDOM(0, 1)
        result = result + r &lt;&lt; i
    if result &gt; range
        return RANDOM(a, b)
    else return a + result

</code></pre>
<h2 id="n2">在雇佣问题中，正好雇佣一次的概率是多少，雇佣n次是多少？雇佣2次</h2>
<p>雇佣一次，最牛的在第一，所以$\frac{(n-1) !}{n !}=\frac{1}{n}$</p>
<p>雇佣n次，就是每个都雇佣，顺序就是1，2，3，4，..n.所以 $\frac{1}{n !}$</p>
<p>雇佣2次：</p>
<ul>
<li>
<p>第一个人肯定雇佣</p>
</li>
<li>
<p>能力最强的人肯定雇佣</p>
</li>
<li>
<p>如果说最强的人在第一个，那么只会雇佣一次</p>
</li>
</ul>
<p>记第一个人的能力为$rank_i$ ，然后$rank_{i+1},...,rank_{n-1}$ (比第一名强的人)要在第一名$rank_{n}$ 之后面试</p>
<p>$P(E_{i})=1/n$ 为 第一名排名为$rank_i$的概率
$$
\sum_{i=1}^{n-1} P\left(E_{i}\right) \cdot \frac{1}{n-i}=\sum_{i=1}^{n-1} \frac{1}{n} \cdot \frac{1}{n-i}
$$</p>
<h2 id="n">掷n个骰子，和的期望</h2>
<p>$X_i$ 第i个骰子的值</p>
<p>$sum=\sum_{i=1}^n X_i$</p>
<p>$E(sum)=E(\sum_{i=1}^n X_i)=\sum_{i=1}^nE(X_i)=3.5n$ </p>
<h2 id="_67">帽子核对问题</h2>
<p>n个客户，每个人给服务生一顶帽子，服务生把帽子以随机顺序还给客户，请问拿到自己帽子的客户数目的期望？</p>
<p>$X_i$ 第 i 个客户拿到自己的帽子</p>
<blockquote>
<p>对于第二个人拿到自己帽子的概率P = 第一个人拿到第二个人的帽子的概率(1/n) * 0 + 第一个人没拿到第二个人的帽子的概率(n-1)/n * (1/n-1) = 1/n， 类比着，不管按照什么顺序，每个人拿到自己帽子的概率都是1/n， 这是古典概型。</p>
</blockquote>
<p>$P(X_i)=1/n$</p>
<p>$E\left[\sum_{i=1}^{n} X_{i}\right]=\sum_{i=1}^{n} E\left[X_{i}\right]=\sum_{i=1}^{n} \frac{1}{n}=1$</p>
<h2 id="_68">逆序对数目的期望</h2>
<p>https://walkccc.me/CLRS/Chap05/5.2/
$$
\begin{aligned}
\mathrm{E}\left[\sum_{i&lt;j} X_{i, j}\right] &amp;=\sum_{i<j} E\left[X_{i, j}\right] \\
&=\sum_{i=1}^{n-1} \sum_{j=i+1}^{n} \operatorname{Pr}\{A[i]>A[j]} \
&amp;=\frac{1}{2} \sum_{i=1}^{n-1} n-i \
&amp;=\frac{n(n-1)}{2}-\frac{n(n-1)}{4} \
&amp;=\frac{n(n-1)}{4} .
\end{aligned}
$$</p>
<h2 id="h">高度为h的堆，最多多少个元素？</h2>
<p>首先要明白堆的定义，是一个近似的完全二叉树</p>
<p>等比数列求和 $S_{n}=a_{1} \frac{1-q^{n}}{1-q}$</p>
<p>对于一个完全二叉树，高度h-1，那么它的元素个数为$1+2+4+8+...+2^{h-1}$</p>
<p>求和为$2^{h}-1$ </p>
<p>那么一个高度为h的堆，放满了为  $2^{h+1}-1$ </p>
<p>前一行放满，第h行放一个，则为：$2^{h}$ </p>
<h2 id="n_1">含有n个元素的堆的高度</h2>
<p>由上题目可知，h高度，最多$2^{h+1}-1$个元素，最少$2^{h}$ </p>
<p>所以n个元素，高度为 $\lfloor\lg n\rfloor$</p>
<h2 id="_69">最大堆的最小元素在哪？</h2>
<p>堆数组的后半部分</p>
<h2 id="_70">已经排好序的数组，是最小堆吗？</h2>
<p>是，parent[i]&lt; left[2i],parent[i]&lt; right[2i+1]</p>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../%E5%8A%9B%E6%89%A3%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/" class="btn btn-neutral float-right" title="力扣题目总结">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../python%E7%9A%84%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/" class="btn btn-neutral" title="python的语言特性"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../python%E7%9A%84%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../%E5%8A%9B%E6%89%A3%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script>var base_url = '../..';</script>
    <script src="../../js/theme_extra.js" defer></script>
    <script src="../../js/theme.js" defer></script>
      <script src="../../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
