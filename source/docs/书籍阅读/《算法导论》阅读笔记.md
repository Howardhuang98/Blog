# 《算法导论》阅读笔记

开始于2021年3月3日  黄浩

答案：https://walkccc.me/CLRS/

## 第一章 算法在计算中的作用

算法algorithm描述一个特定的计算过程来实现输入和输出的关系

* 算法问题的两个特征：

存在许多候选解，寻找一个真正的解或者一个最好的解可能是一个很大的挑战；

存在实际应用。

* 数据结构

数据结构是数据的储存和组织方式，旨在方便访问与修改

* 技术

本书有一些特定的问题解决方法

* 难题

一部分问题，目前不知道有效的方法，被称为**NP完全的**。请参照第34章学习NP完全性。



特点：1. 对于NP完全问题，目前没有找到有效的算法，但是也没人能证明NP完全的问题确实不存在有效算法。

​			2. 如果NP完全问题被解决，那么一系列的NP完全问题都会被解决

“旅行商问题”，NP完全问题一般寻求近似算法。

* 并行性

### 作为一种技术的算法

计算机有两个限制：速度与储存

指令/速度 = 时间

指令数目与算法与编译器有关

速度与计算机速度有关。

### 算法的重要性

#### 比较插入排序与并归排序

比较插入顺序与归并顺序在相同机器上的实现。输入规模为n，插入排序运行8n^2步，而并归排序运行64n lgn 步，问对于哪些n值，插入排序优于归并排序

<img src="%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210303150617358-16478516959433.png" alt="image-20210303150617358"  />

n取2，3，4，5，6。

## 第二章 算法基础

### 插入排序

```python
def insertion_sort(A):
    for j in range(1,len(A)):
        key = A[j]
        i = j - 1
        while i >= 0 and A[i] > key:
            A[i+1] = A[i]
            i -= 1
        a[i+1] = key
```

注意边界条件，以及**循环不变式**：A[:j]是排序好了的，比如 j=1的时候，A[0]一个元素就是排序好了的。

插入排序适用于少量元素的排序。

![image-20210303152602643](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210303152602643.png)

![image-20210303160204515](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210303160204515.png)

这是一个$O(n^2)$的算法。

### 分析算法

**插入排序算法的分析**

输入规模

运行时间，指执行的基本操作数或步数

![image-20210304143251776](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210304143251776.png)

得到运行时间为：

![image-20210304143319906](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210304143319906.png)

最佳情况，就是输入的就是个已经排序拍好的：

![image-20210304143426145](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210304143426145.png)

最坏情况，输入是相反排序的：

![image-20210304143829191](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210304143829191.png)

**最坏情况**

**平均情况分析**

**增长量级**

使用一些简化抽象，比如忽略上文中的c，即每个指令的时间，而关注最重要的项。对于足够大的输入，最高阶项起最大作用。

![image-20210304144146839](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210304144146839.png)

### 设计算法

插入排序采用了**增量的方法**：在排序好前 [1: j-1]个元素以后，再将当个j元素插入到子数组的适当位置，产生排序好的子数组 [0: j]

#### 分治法

分治法的思想：将原问题分解为几个规模较小但类似于原问题的子问题，递归地求解这些子问题、

分治的模式：

* 分解
* 解决这些子问题
* 合并

**归并排序算法**完全遵循分治模式：

分解：讲待排序的n个元素的序列分解为n/2个元素的子序列；

解决: 使用归并排序解决子序列；

合并：将两个已经排序完成的子序列合并。



**合并函数 merge**：

输入数组，p，q，r，分成两段，将两组进行合并: 

```python
def merge(A, p, q, r):
    """
    A数组分为两个部分，A[p,q],A[q,r]
    """
    L = [i for i in A[p:q]]
    R = [i for i in A[q:r]]
    # 额外的空间，储存L,R， 加上哨兵，以免i，j指针移到外面去了
    L.append(float("+inf"))
    R.append(float("+inf"))
    i = 0
    j = 0
    for k in range(p, r):
        # 小的进入
        if L[i] <= R[j]:
            A[k] = L[i]
            i += 1
        else:
            A[k] = R[j]
            j += 1
```

将merge作为归并排序算法中的一个子程序来用：

```python
def merge_sort(A, p, r):
    if p < r-1:
        # 找中点位置
        q = int((r + p) / 2)
        merge_sort(A, p, q)
        merge_sort(A, q, r)
        merge(A, p, q, r)
    return A
```

在写这样的递归调用时候，一定要明确终止深入的条件。在归并排序中，p<r-1时才深入，否则（1>=r-q）并不执行merge_sort，因为只有1个元素。

#### 分析分治算法

![image-20210308113515500](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210308113515500.png)

**并归排序算法的分析**

![image-20210308113646493](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210308113646493.png)

忽略低阶项和常数c便给出期望的结果O(nlgn) 

**思考题**

![image-20210308154006629](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210308154006629.png)

冒泡排序的最坏情况运行 O(n^2^)，插入排序的最坏运行也是O(n^2^)

![image-20210308160343847](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210308160343847.png)

b. n-1 + ... +1 = n(n-1)/2 个 

## 第三章 函数的增长

算法运行时间的增长量级简单地刻画了算法的效率。

当输入规模n变得足够大，最坏运行时间为$\Theta(n \lg n)$ 的并归排序将战胜插入排序$\Theta\left(n^{2}\right)$

### 渐近记号

$\Theta$记号

![image-20210309154546108](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210309154546108.png)

![image-20210309154601231](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210309154601231.png)

$O$ 记号：渐近上界

$\Omega$记号：渐近下界

各种渐近关系符合：传递性，自反性，对称性，转置对称性，三分性

### 标准记号与常用函数

* 单调性
* 向下取整与向上取整
* 模运算
* 多项式
* 指数
* 对数
* 阶乘
* 多重函数
* 多重对数函数
* 斐波那契数
* ![image-20210309163840558](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210309163840558.png)



![image-20210309154910032](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210309154910032.png)

## 第四章 分治策略

分治的策略中，我们使用递归来解决问题。

三个核心：

1. 分解为子问题
2. 解决，也可以理解为终止条件
3. 合并

### 递归式

分治的规模对分治法的性能影响很大。

例如对半分（分治排序）：

![image-20220315161441624](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20220315161441624.png)

还可以1/3,2/3分

减少一个元素分：

![image-20220315161528006](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20220315161528006.png)

**不同的递归式，其复杂度也大不相同！

当子问题足够大需要递归求解时，我们称之为**递归情况**

当子问题足够小，不再需要递归时，说明递归已经触底，进入了**基本情况**

递归式：

![image-20210310140240348](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210310140240348.png)



求解可得：

![image-20210310140301895](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210310140301895.png)

求解递归式的方法：代入法，递归树法，主方法。

### 最大数组问题

![image-20210310151258397](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210310151258397.png)

* 暴力求解法
* 问题变换
* 使用分治策略的求解法

使用分治算法的复杂度为

![image-20210310163759716](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210310163759716.png)

**练习**

![image-20210310163824523](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210310163824523-16478513544691.png)

![comparison between Divide-and-Conquer and Traversal Algorithm](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/comparison%20between%20Divide-and-Conquer%20and%20Traversal%20Algorithm.PNG)

![image-20210310184325798](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210310184325798.png)

这道题需要采用动态规划的办法解决。**尚未解决**

### 矩阵乘法的Strassen算法

![image-20210310184928910](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210310184928910.png)

![image-20210310184941419](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210310184941419.png)

时间复杂度为$\Theta\left(n^{3}\right)$，但是Strassen的著名n*n矩阵相乘的递归算法，复杂度为$\Theta\left(n^{\lg 7}\right)$，其中lg7约为2.8和2.81。

 递归算法时间复杂度也是时间复杂度为$\Theta\left(n^{3}\right)$。

![image-20210311153047731](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210311153047731.png)

![image-20210311153323685](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210311153323685.png)

其中$\Theta(1)$ 是分解A,B,C矩阵。$\Theta\left(n^{2}\right)$ 是元素相加。

注意8T(n/2)中的8决定了递归树是否茂盛，不能省略，否则就是线性结构了。

**Strassen算法**

其核心思想就是将8T(n/2)改为7T(n/2)

伪代码（自写）：

```伪代码
def Strassen(a,b):
	n = a的维度
	c = n*n matrix
	if n == 1:
		c11 = a11*b11
	else:
		s1 = b12-b22
		s2 = a11+a12
		s3 = a21+a22
		s4 = b21-b11
		s5 = a11+a22
		s6 = b11+b22
		s7 = a12-a22
		s8 = b21+b22
		s9 = a11-a21
		s10 = b11+b12
		p1 = Strassen(a11,s1)
		p2
		p3
		p4
		p5
		p6
		p7
		c11 = 
		c12
		c21
		c22
	return c	
```

练习：

![image-20210312134101025](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210312134101025.png)

### 求解递归式

**代入法**，它主要分为两步：

1. 猜测解的形式
2. 用数学归纳法求出解的常数，并证明解是正确的

![image-20210312135112388](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210312135112388.png)

* 猜测：

上界为：

![image-20210312135138868](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210312135138868.png)

* 要求证明：

![image-20210312135431289](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210312135431289.png)

![image-20210312135600561](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210312135600561.png)

**递归树**

例如：

![image-20210312135659962](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210312135659962.png)

![image-20210312135710128](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210312135710128.png)

![image-20210312135923836](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210312135923836.png)

![image-20210312140214317](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210312140214317.png)

**主方法**

（略）

## 第五章 概率分析和随机算法

### 雇佣问题

![image-20210312143526161](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210312143526161.png)

伪代码：

![image-20210312143545103](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210312143545103.png)

最坏情形分析

![image-20210312144552178](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210312144552178.png)

**随机算法**

为了利用概率分析，需要了解关于输入分布的一些信息。

### 指示器随机变量

![image-20210312160323249](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210312160323249.png)

![image-20210312161021096](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210312161021096.png)

### 随机算法

如何理解随机排序，一个公平的算法能够均匀地给出n！个结果中的一个。但是如果这样的话，算法需要给出n！个选择，它的复杂度太高O(n!)，随机算法应运而生。

随机排列数组：

![image-20210312165243306](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210312165243306.png)

P表示的是优先级：假设优先级都不同，则算法产生输入的均匀随机排列。

![image-20210312171354302](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210312171354302.png)

**小tip：**

![image-20210312204458308](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210312204458308.png)

### Knuth洗牌算法

![image-20210312204550250](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210312204550250.png)

![img](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/v2-1b4e619875fa6eed722fc0fcd30f4131_720w.jpg)

![img](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/v2-1c7f79a322e8a9687eaaa648863efb0d_720w.jpg)

![img](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/v2-d930f1a8f34c2a5056fa58048ad762e8_720w.jpg)

![img](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/v2-fe5a19b92bf338722a35c017ad75127a_720w.jpg)

![img](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/v2-90f4110c3954039a95995834021ad4f0_720w.jpg)

![img](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/v2-c69895a774b2ff22d03220aaec22ff3a_720w.jpg)

![img](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/v2-9de51683f0df5707cda76b9ea784f1df_720w.jpg)

![img](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/v2-d89b5143bce1f4580a77b5a384e475d8_720w.jpg)



排序问题：

![image-20210312205328951](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210312205328951.png)

**排序算法：**

插入排序，$\Theta\left(n^{2}\right)$，他是原址的（仅有常数项个元素需要储存在数组之外），对于小规模排序，插入排序非常适用。

归并算法，$\Theta(n \lg n)$，它的merge函数并不是原址的，但他有更好的渐进时间。

在下文中 第六场介绍堆排序，第七章介绍快速排序。

![image-20210312205929251](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210312205929251.png)

## 第六章 堆排序

**它融合了快速排序和归并排序的优点**

利用堆的数据结构，结合了插入排序和归并排序的优点：复杂度$\Theta(n \lg n)$，具有原址性。

### 堆

**堆是一个数组，一个近似的完全二叉树**

![image-20210312213952774](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210312213952774.png)

计算位置：

<img src="%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210312214009810.png" alt="image-20210312214009810" style="zoom: 67%;" />

最大堆，最小堆。最大堆就是最大的节点在最上面的根节点。

最大堆的一些性质：

1. 最大堆的最大值在根节点上，在python中，一般使用最小堆，根节点是最小值
2. 构造最大堆，线性复杂度
3. 维护最大堆，复杂度为 $O(lgn)$，只能
4. 堆排序  $O(nlgn)$

![image-20210312215219362](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210312215219362.png)

![image-20210312215242027](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210312215242027.png)

### 维持最大堆

![image-20210312222646875](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210312222646875.png)

![image-20210312222709066](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210312222709066.png)

复杂度：O(lgn)

维护最大堆：就是把第i个元素和两个孩子做对比，与孩子中的较大值进行交换。

### 建堆

自底向上建造最大堆。

数学归纳可知: (n-1)//2+1 到 n 均为 叶子，那么（n-1）//2 为非叶子，所以对这些进行最大堆维护即可

![image-20210317202340578](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210317202340578.png)

### 堆排序

![image-20210317213835349](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210317213835349.png)



**需要一定的数学证明：堆排序的时间复杂度为nlogn**

![image-20210317213925271](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210317213925271.png)

### 优先队列 

用最大堆实现最大优先队列

优先队列的每一个元素都有一个相关的值，称为关键字KEY，最大优先队列支持以下操作：

insert(s,x):把元素插入到集合x中

maximum(s):返回s中最大元素

extract-max(s):去掉并返回s中具有最大关键字的元素

increase-key(s,x,k):将元素x的关键字值增加到k，假设k值不小于原来的关键字值

** 插入就直接在数组后方加入，然后注意维护堆即可

![image-20210317223233076](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210317223233076.png)



![image-20210317223334639](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210317223334639.png)

![image-20210317223347158](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210317223347158.png)

![image-20210317223358182](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210317223358182.png)

先改变A[i]的值，然后在‘’原有的最大堆‘’上维护最大堆。

![image-20210317223530607](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210317223530607.png)

## 第七章 快速排序

快速排序是实际排序应用中的最好选择，它的平均性能最好，期望时间复杂度还是$\Theta(n \lg n)$，但是隐含的常数因子非常小，他也能进行原址排序，甚至虚拟环境中也能很好地工作。

**分治的思想**

![image-20210318110659609](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210318110659609.png)

 算法可以基于原址，所以不需要归并，只需要做好分割即可。

**分割函数**

![image-20210318113111431](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210318113111431.png)

![image-20210318121732644](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210318121732644.png)

### 快速排序的性能分析

**最坏情况划分**

如果每次划分都包含了n-1和1个元素，那是最差的情况，划分操作复杂度为n

![image-20210318122456549](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210318122456549.png)

复杂度结果为：$\Theta\left(n^{2}\right)$

**最好情况划分**

![image-20210318123622903](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210318123622903.png)

复杂度结果为$\Theta(n \lg n)$

**平衡的划分**

快速排序的平均运行时间更接近于其最好情况，并非最坏情况

（个人理解：每次划分，都分到到最差情况的概率是非常小的）

### 快速排序的随机化版本

主要修改是将主元素随机选取

![image-20210318124141954](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210318124141954.png)



| 插入排序 | 插入扑克牌式                     |
| -------- | -------------------------------- |
| 归并排序 | 分治                             |
| 堆排序   | 最大堆的维护始终能找到最大的元素 |
| 快速排序 | 分割                             |



## 第八章 线性时间排序

之前提到的算法都有一个性质：在排序的最终结果中，个元素的次序依赖于它们之间的比较。**比较排序**

### 排序算法的下界

决策树模型---完全二叉树

<img src="%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210318212924801.png" alt="image-20210318212924801" style="zoom:67%;" />

叶节点共有n！种可能的排列。

### 最坏情况的下界

排序算法最坏情况就是决策树的高度

定理：

* 最坏情况下，任何比较排序算法都需要$\Omega(n \lg n)$次比较

* 堆排序和归并排序都是渐进最优的排序算法

![image-20210319172828413](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210319172828413.png)

### 计数排序

![image-20210319174054532](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210319174054532.png)

图解：

![image-20210319174124617](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210319174124617.png)

运行时间为：$\Theta(n)$

计数排序的一个重要性质就是**稳定**，对于相同值的元素在输出数组中的相对次序与他们在输入数组中的次序相同，这种稳定性在当有数据附带卫星数据时比较重要。

![image-20210319174502412](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210319174502412.png)

### 基数排序

![image-20210322125301733](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210322125301733-16478515658861.png)

伪代码：

![image-20210322125320869](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210322125320869.png)

引理：

采用稳定排序方法，比如计数排序：$\Theta(d(n+k))$ ，即运行d次计数排序。

**基数排序是否比基于比较的排序算法更好呢？**

基数排序虽然执行的循环轮数会比快速排序少，但是每一轮它所耗费的时间要长的多，哪一种排序合适更依赖于具体实现和底层的特性，比如快速排序通常比基数排序更有效地使用硬件的缓存。

![image-20210322164126997](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210322164126997.png)

### 桶排序

桶排序假设输入数据服从均匀分布，平均情况下它的时间代价为$O(n)$。

![image-20210322152251746](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210322152251746.png)

![image-20210322152306518](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210322152306518.png)

## 第九章 中位数和顺序统计量

order statistic 第i个顺序统计量是该集合中第i个元素

最大值 i = n

最小值 n = 1

n为偶数时存在两个中位数，下中位数/上中位数



### 最小值和最大值

![image-20210324134833603](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/image-20210324134833603-16478515730862.png)



经过n-1次比较找出最大值或最小值。

### 期望为线性时间的选择算法

选择数组中第i小的元素

![image-20210324140105770](%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0.assets/image-20210324140105770.png)

此处的partition是快速排序的分割（分成三段，第一段小于key，第二段为key，第三段大于key）

## 第十章 基本数据结构

栈，队列，链表，有根树。

### 栈和队列

栈和队列都是动态集合，在其上进行delete操作是预定的：

栈：后进先出

队列：先进先出

**栈**

insert操作被称为压入push

delete操作被称为弹出pop

![image-20210324142310388](%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0.assets/image-20210324142310388.png)

**队列**

insert: enqueue

delete: dequeue 

![image-20210324142758700](%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0.assets/image-20210324142758700.png)

### 链表

双向链表

prev - element - next

![image-20210324142917842](%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0.assets/image-20210324142917842.png)

**哨兵**

![image-20210324143837463](%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0.assets/image-20210324143837463.png)

L.nil 的next 指向第一个元素（表头）

L.nil的prev 指向最后一个元素（表尾）

所以此处不需要L.head

只需要L.nil.next

### 有根树

树可以分为多种树，二叉树，分支无限制的有根树。。。等等

#### 二叉树

![image-20220315174746798](%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0.assets/image-20220315174746798.png)

#### 分支无限制的有根树

![image-20220315174807252](%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0.assets/image-20220315174807252.png)

## 第十一章 散列表

待完成。。。

## 第十二章 二叉搜索树

![image-20220315175149485](%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0.assets/image-20220315175149485.png)

#### 中序遍历、前序遍历，后序遍历

采用**递归**的方式进行遍历，也可以用**栈**。 

上面的树的中序遍历为

2，5，5，6，7，8

> 如果想一层层的遍历，采用广度优先搜索，借用队列

## 第十五章 动态规划

dynamic programming 动态规划

特征：

1. 找的是最优解。
2.  最优子结构：最优解=f(最优子结构)
3. 重叠子问题：当处理子问题的时候，会遇到重复的情况，所以归并排序并不属于动态规划。

两种实现方法：

1. 自上而下：采用备忘录的方式
2. 自下而上：构建表格，也称为的dp数组

### 设计方法

1. 写出递归函数\贝尔曼方程\最优解的结构特征
2. 计算最优解的值，通常采用自底向上的方法

### 自下而上的一维数组

#### 钢管切割

![image-20220316141256924](%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0.assets/image-20220316141256924.png)

1. 找最优解
2. 存在最优子结构

> 此时已经可以采用递归的方式进行求解了，递归复杂度太高了，指数级

			3. 发现重叠子结构
			3. 动态规划！
			3. 选择：自上而下，或者**自下而上**

首先写出递归公式：
$$
r_n = max[p_1+r_{n-1}, p_2+r_{n-2},...,p_n]
$$
递归公式，左边由多个值计算而来，
$$
r_1 = p_1 \\
r_2 = r_1 + p_1 或 p_2 \\
r_3 = r_1 + p_2 或 r_2+ p_1 或 p_3  
$$
可以看到，r就是通过前面的数算出来的，就构建数组，初始化$r_1$ ，开始向上计算。

### 自下而上的二维数组

对于一维问题
$$
f(0:n) = a+f(1:n)
$$
二维问题：
$$
f(0:n)=f(0:k)+f(k:n)
$$


#### 矩阵链乘

![image-20220316144301160](%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0.assets/image-20220316144301160.png)

![image-20220316144233829](%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0.assets/image-20220316144233829.png)

找最优化方案，明确这是一个最优化问题。

写递归方程：

![image-20220316144724318](%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0.assets/image-20220316144724318.png)

m表是dp表

s表用于记录最佳分割位置k

![image-20220316145151893](%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0.assets/image-20220316145151893.png)

#### 最长公共子序列

![image-20220316151838506](%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0.assets/image-20220316151838506.png)

1. 刻画最长公共子序列的特征
   1. X有$2^m$个子序列，全部遍历一边，可以找到最长的

![image-20220316152556809](%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0.assets/image-20220316152556809.png)

### 最优二叉搜索树

涉及概率，有点难，待完善。

### 自上而下的备忘录机制



## 第二十二章 图算法

图的表示：

* 邻接链表

在表示稀疏图的时候非常适用

* 邻接矩阵

表示稠密图适用，可以快速判断两个节点是否存在边

![image-20210314204153547](%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0.assets/image-20210314204153547.png)

无论是有向图还是无向图，邻接链表的储存空间需求为：$\Theta(V+E)$

邻接链表稍加修改即可表示**权重图**，不足在于不能快速判断是否存在某个边，要去搜索。

邻接矩阵可以快速判断是否存在某个边，但是储存空间较大。需求为：$\Theta\left(V^{2}\right)$

无向图是对称的，可以节约一半的空间。

![image-20210324145908829](%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0.assets/image-20210324145908829.png)

#### 例题

![image-20220316001430885](%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0.assets/image-20220316001430885.png)

对于邻接链表来说：

遍历每个结点，每个节点的边进行翻转

邻接矩阵

上下三角对换。



有向无环图



### 广度优先搜索

该算法能够计算节点s到每个可到达的结点的距离（最少的边数），同时生成一颗广度优先搜索树。

s -- v的最短路径。



先找出灰色

灰色中选择一个变黑，变黑元素周围变灰

再找出灰色

如此反复。

https://www.redblobgames.com/pathfinding/a-star/introduction.html 

可以参考学习

**最短路径**

广度优先搜索可以计算出最短路径。

**最短路径距离的一些性质**





# 问题，自测

## 描述归并排序

## 证明归并排序的时间复杂度

画图、数学归纳法

## 二分查找描述，复杂度

## 描述一个算法，数组中找和为x的元素对，nlogn

归并法



## 逆序对

归并法

## 如果只能调用random(0,1)，如何做到random(a,b),返回ab之间的整数、

首先，random(0,1)是随机的产生0,1两个整数，random(a,b)是随机产生[a,b]之间的整数。

实际上要随机生成一个 [0,b-a]的数，最后加上a。

为了生成这个数，那就要生成2进制数，bits，通过random(0,1）生成的二进制数都是等概率的。

所以逻辑就是，用random(0,1)生成一个二进制数

```
RANDOM(a, b)
    range = b - a
    bits = ceil(log(2, range))
    result = 0
    for i = 0 to bits - 1
        r = RANDOM(0, 1)
        result = result + r << i
    if result > range
        return RANDOM(a, b)
    else return a + result

```

## 在雇佣问题中，正好雇佣一次的概率是多少，雇佣n次是多少？雇佣2次

雇佣一次，最牛的在第一，所以$\frac{(n-1) !}{n !}=\frac{1}{n}$

雇佣n次，就是每个都雇佣，顺序就是1，2，3，4，..n.所以 $\frac{1}{n !}$

雇佣2次：

* 第一个人肯定雇佣

* 能力最强的人肯定雇佣

* 如果说最强的人在第一个，那么只会雇佣一次

记第一个人的能力为$rank_i$ ，然后$rank_{i+1},...,rank_{n-1}$ (比第一名强的人)要在第一名$rank_{n}$ 之后面试

$P(E_{i})=1/n$ 为 第一名排名为$rank_i$的概率
$$
\sum_{i=1}^{n-1} P\left(E_{i}\right) \cdot \frac{1}{n-i}=\sum_{i=1}^{n-1} \frac{1}{n} \cdot \frac{1}{n-i}
$$

## 掷n个骰子，和的期望

$X_i$ 第i个骰子的值

$sum=\sum_{i=1}^n X_i$

$E(sum)=E(\sum_{i=1}^n X_i)=\sum_{i=1}^nE(X_i)=3.5n$ 

## 帽子核对问题

n个客户，每个人给服务生一顶帽子，服务生把帽子以随机顺序还给客户，请问拿到自己帽子的客户数目的期望？

$X_i$ 第 i 个客户拿到自己的帽子

> 对于第二个人拿到自己帽子的概率P = 第一个人拿到第二个人的帽子的概率(1/n) * 0 + 第一个人没拿到第二个人的帽子的概率(n-1)/n * (1/n-1) = 1/n， 类比着，不管按照什么顺序，每个人拿到自己帽子的概率都是1/n， 这是古典概型。

$P(X_i)=1/n$

$E\left[\sum_{i=1}^{n} X_{i}\right]=\sum_{i=1}^{n} E\left[X_{i}\right]=\sum_{i=1}^{n} \frac{1}{n}=1$

## 逆序对数目的期望

https://walkccc.me/CLRS/Chap05/5.2/
$$
\begin{aligned}
\mathrm{E}\left[\sum_{i<j} X_{i, j}\right] &=\sum_{i<j} E\left[X_{i, j}\right] \\
&=\sum_{i=1}^{n-1} \sum_{j=i+1}^{n} \operatorname{Pr}\{A[i]>A[j]\} \\
&=\frac{1}{2} \sum_{i=1}^{n-1} n-i \\
&=\frac{n(n-1)}{2}-\frac{n(n-1)}{4} \\
&=\frac{n(n-1)}{4} .
\end{aligned}
$$

## 高度为h的堆，最多多少个元素？

首先要明白堆的定义，是一个近似的完全二叉树

等比数列求和 $S_{n}=a_{1} \frac{1-q^{n}}{1-q}$

对于一个完全二叉树，高度h-1，那么它的元素个数为$1+2+4+8+...+2^{h-1}$

求和为$2^{h}-1$ 

那么一个高度为h的堆，放满了为  $2^{h+1}-1$ 

前一行放满，第h行放一个，则为：$2^{h}$ 

## 含有n个元素的堆的高度

由上题目可知，h高度，最多$2^{h+1}-1$个元素，最少$2^{h}$ 

所以n个元素，高度为 $\lfloor\lg n\rfloor$

## 最大堆的最小元素在哪？

堆数组的后半部分

## 已经排好序的数组，是最小堆吗？

是，parent[i]< left[2i],parent[i]< right[2i+1]

## 二叉树的理解

对于二叉树的处理，由两种思维模式：

1. 遍历一边二叉树解决问题；
2. 通过子树的答案来结决问题。

一定需要思考的问题：**只给你一个二叉节点，你要如何解决这个问题呢**？

### 如何理解前中后序遍历？

```python
def traverse(node):
	"""
	后序遍历
	"""
	traverse(node.left)
	traverse(node.right)
	print(node.val)
```

树可以被前中后序遍历，同样的，链表也可以被**前、后序遍历**。

> 思考：如何从后面开始打印链表呢？
>
> 答：链表的后序遍历。

任何递归操作都可以被理解为前中后序遍历。

**前中后序遍历是二叉树树处理过程中的时间节点**！

1. 前序位置的代码在刚刚进入一个二叉树节点的时候执行；

2. 后序位置的代码在将要离开一个二叉树节点的时候执行；

3. 中序位置的代码在一个二叉树节点左子树都遍历完，即将开始遍历右子树的时候执行。

这三点的理解对于回溯等算法的理解非常重要。

前序位置可以做检查；

后续位置可以做记忆；

![img](%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.assets/2.jpeg)

一般情况下，对位置不敏感的操作都放在前序位置；后续位置可以获得子树的信息。

练习：https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/

主要的操作在后序上。

练习：https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/

二叉搜索树第k小的元素

二叉搜索树具有如下性质：

- 结点的左子树只包含**小于**当前结点的数。
- 结点的右子树只包含**大于**当前结点的数。
- 所有左子树和右子树自身必须也是二叉搜索树。

最重要的是，**二叉搜索树的中序遍历就是升序的**！！！！
