# 《操作系统》

### 定义

操作系统是一个控制程序；

管理应用程序；

为应用程序提供服务；

杀死应用程序；

资源管理；

管理外设，分配资源；

### 层次

硬件之上

应用程序之下

![image-20210903143446646](《操作系统》.assets/image-20210903143446646.png)

### 内部组件

CPU调度器

物理内存

虚拟内存

文件系统管理

中断处理与设备驱动

### 概念

并发：一段时间内，多个程序运行

并行：一个时间点，多个程序运行

虚拟化：一台物理机器虚拟为多台机器

### 类别

UNIX BSD家族 

unix 伯克利家族

Linux家族

windows家族  

### 发展

60年代 批处理

内存容量越来越大，CPU执行多个程序 --并发

IO执行慢，使得等待时间让其他程序来执行

![image-20210903145941439](《操作系统》.assets/image-20210903145941439.png)

（调度，中断）

分时系统，分时调动。

千分之一秒----时间片，轮流切换运行。“时钟”定期产生中断

分布式操作系统 

### 架构

松耦合

![image-20210903150708045](《操作系统》.assets/image-20210903150708045.png)

紧耦合



虚拟机

### 启动

disk 存放OS，bootloader

BIOS 基本IO系统

![image-20210903151216491](《操作系统》.assets/image-20210903151216491.png)

加电自检

寻找显卡和执行BIOS

![image-20210903151434645](《操作系统》.assets/image-20210903151434645.png)

先加载bootloader，bootloader加载os

### 中断，异常，系统调用

系统调用：

应用程序向OS发出服务请求

异常：

非法程序，非法指令

中断：

来源于外设



在计算机中，内核是被信任的第三方

只有内核可以执行特权指令

为了方便应用程序



处理时间：

中断：异步

异常：同步

系统调用：异步与同步



响应：

中断：应用程序无法感知

异常：杀死或重新执行

系统调用：等待和持续

### 中断

硬件：设置中断标记（cpu初始化）。

操作系统：保存程序执行的现场。

软件：保存当前处理状态，中断服务程序，清除中断标记，回复

### 异常

异常现场

异常处理

恢复现场

### 系统调用

系统调用接口

print 调用系统接口 write

Win32 API 用于 windows

https://docs.microsoft.com/en-us/windows/win32/apiindex/windows-api-list

POSIX API

Java API 用于 java 虚拟机

![image-20210903153313091](《操作系统》.assets/image-20210903153313091.png)

### 计算机体系结构以及内存分层体系

![image-20210903153811763](《操作系统》.assets/image-20210903153811763.png)

![image-20210903153940210](《操作系统》.assets/image-20210903153940210.png)

主存就是物理内存，比寄存器与cache大很多，但速度不如寄存器与cache。

越靠近CPU越快，但是容量越小 -- 层次结构 

![image-20210903154205463](《操作系统》.assets/image-20210903154205463.png)

### 地址空间与地址生成

物理地址空间，硬件支持的地址空间；

逻辑地址空间，应用程序所拥有的内存范围。

逻辑地址空间都是落实在物理地址空间内的

案例：c程序

![image-20210903154818159](《操作系统》.assets/image-20210903154818159.png)

c编译为汇编，汇编用汇编器转化为机器语言

逻辑地址---映射--->物理地址  CPU 的MMU查找映射表

### 内存碎片问题

空闲内存不能被利用

* 外部碎片
* 内部碎片



### 分区的动态分配

用数据结构与算法进行管理

* 首次适配算法

![image-20210903155727250](《操作系统》.assets/image-20210903155727250.png)

简单，容易产生外碎片，不确定性

* 最优适配算法

找到最适合的空闲块

![image-20210903160016737](《操作系统》.assets/image-20210903160016737.png)

避免切割大空闲块，最小化外部碎片。需要按size排序，容易产生微小外碎片

* 最坏适配算法

![image-20210903160211089](《操作系统》.assets/image-20210903160211089.png)

容易破碎大的空闲块。

### 压缩式与交换式碎片整理

SWAP 换入换出

![image-20210903160828390](《操作系统》.assets/image-20210903160828390.png)

https://www.bilibili.com/video/BV1wq4y1M7qf?p=15&spm_id_from=pageDriver

### 非连续内存分配

连续内存分配：给应用程序分配的地址空间是连续的

建立虚拟地址和物理地址之间的转换

* 软件方案
* 硬件方案

两种硬件方案：分段，分页



### 分段

![image-20210903203536142](《操作系统》.assets/image-20210903203536142.png)

![image-20210903203616722](《操作系统》.assets/image-20210903203616722.png)

![image-20210903203718581](《操作系统》.assets/image-20210903203718581.png)

![image-20210903203822554](《操作系统》.assets/image-20210903203822554.png)

![image-20210903204001037](《操作系统》.assets/image-20210903204001037.png)

段表中存储： 起始，长度

段表是OS早就建立好的，依据具体硬件

### 分页

* 分页的地址空间
* 分页寻址

页号，页偏移

页的大小不变，页---》物理页：贞的映射关系

![image-20210903204458332](《操作系统》.assets/image-20210903204458332.png)

![image-20210903204746919](《操作系统》.assets/image-20210903204746919.png)

页表由操作系统建立

![image-20210903205240855](《操作系统》.assets/image-20210903205240855.png)

多级页表 

节省空间

![image-20210903205429841](《操作系统》.assets/image-20210903205429841.png)

![image-20210903205902076](《操作系统》.assets/image-20210903205902076.png)

反向页表，根据物理地址找到页贞号

![image-20210903205950450](《操作系统》.assets/image-20210903205950450.png)

关联内存方案。

基于哈希查找

### 虚拟内存

![image-20210903210607605](《操作系统》.assets/image-20210903210607605.png)

* 手动覆盖
* 自动交换
* 自动的虚拟内存

https://www.bilibili.com/video/BV1wq4y1M7qf?p=21

### 覆盖技术

![image-20210905130251399](《操作系统》.assets/image-20210905130251399.png)

### 交换技术

![image-20210905135354103](《操作系统》.assets/image-20210905135354103.png)

![image-20210905135418612](《操作系统》.assets/image-20210905135418612.png)

### 虚拟内存管理技术

内存不够的情况下，可以采用覆盖技术和交换技术

虚存技术：

不是把程序的所有内容都放在内存中；

动态实现内存与外存之间的交换。

程序的局部性原理：程序在执行过程中的一个较短的时期，所执行的指令地址和指令的操作地址，分别局限于一定的空间。

### 进程

process 

![image-20210905140643306](《操作系统》.assets/image-20210905140643306.png)

![image-20210905140752057](《操作系统》.assets/image-20210905140752057.png)

![image-20210905140921242](《操作系统》.assets/image-20210905140921242.png)

![image-20210905141246941](《操作系统》.assets/image-20210905141246941.png)

![image-20210905141413124](《操作系统》.assets/image-20210905141413124.png)

进程是一个动态的过程。

![image-20210905141532450](《操作系统》.assets/image-20210905141532450.png)

![image-20210905141911653](《操作系统》.assets/image-20210905141911653.png)

### 进程控制块

PCB process control block

三个信息：

进程标识 PID

处理机状态信息保存区

* 用户可见寄存器
* 控制和状态寄存器
* 栈指针 

![image-20210905143053168](《操作系统》.assets/image-20210905143053168.png)

![image-20210905143107922](《操作系统》.assets/image-20210905143107922.png)

组织方式：

链表

索引表

![image-20210905143325864](《操作系统》.assets/image-20210905143325864.png)

### 进程的生命周期

进程创建

进程运行

进程等待

进程唤醒

进程结束

![image-20210905143503480](《操作系统》.assets/image-20210905143503480.png)

![image-20210905143611964](《操作系统》.assets/image-20210905143611964.png)

![image-20210905143629757](image-20210905143629757.png)

![image-20210905143816867](《操作系统》.assets/image-20210905143816867.png)

![image-20210905143839954](《操作系统》.assets/image-20210905143839954.png)

### 进程状态变化模型

![image-20210905143959103](《操作系统》.assets/image-20210905143959103.png)

![image-20210905144034786](《操作系统》.assets/image-20210905144034786.png)

![image-20210905144100393](《操作系统》.assets/image-20210905144100393.png)

时间片完，多个程序高速切换运行。

### 进程挂起

挂起与进程的阻塞不同。

进程挂起意味着进程没有占用内存空间，处于挂起的进程映像在硬盘上。

![image-20210905144553179](《操作系统》.assets/image-20210905144553179.png)

![image-20210905144844464](《操作系统》.assets/image-20210905144844464.png)

![image-20210905145008200](《操作系统》.assets/image-20210905145008200.png)

操作系统要维护一系列进程。

![image-20210905145151203](《操作系统》.assets/image-20210905145151203.png)

### 线程

![image-20210905145413663](《操作系统》.assets/image-20210905145413663.png)

read()阻塞了整个程序进行

![image-20210905145532005](《操作系统》.assets/image-20210905145532005.png)

线程：如同进程一样并发运行

但是线程之间共享相同的地址空间。

![image-20210905205930207](《操作系统》.assets/image-20210905205930207.png)

线程的优点：

一个进程中可以同时存在多个线程

各个线程并发进行

各个线程共享资源

缺点：

一个线程崩溃，会导致其所属的进程所有的线程崩溃。



多线程 适用于高性能计算

多进程 适用于网络浏览器

![image-20210905210542574](《操作系统》.assets/image-20210905210542574.png)

![image-20210905210742192](《操作系统》.assets/image-20210905210742192.png)

 

### 线程的实现

用户线程

内核线程

![image-20210905211148037](《操作系统》.assets/image-20210905211148037.png)

![image-20210905211502869](《操作系统》.assets/image-20210905211502869.png)

### 上下文切换 

![image-20210905211916984](《操作系统》.assets/image-20210905211916984.png)

![image-20210905211927308](《操作系统》.assets/image-20210905211927308.png)

 ### 进程加载 



### CPU调度

进程上下文切换

CPU调度：从就绪队列中挑选一个进程/线程作为CPU将要运行的下一个进程

调度程序：挑选进程的内核函数

什么时候调度

![image-20210905213317356](《操作系统》.assets/image-20210905213317356.png)

![image-20210905213759566](《操作系统》.assets/image-20210905213759566.png)

### 调度原则

充分地利用CPU。

![image-20210905214310238](《操作系统》.assets/image-20210905214310238.png)

评价指标：

![image-20210905214342794](《操作系统》.assets/image-20210905214342794.png)

### 调度算法

![image-20210905215007544](《操作系统》.assets/image-20210905215007544.png)



First Come First Server

![image-20210905215332873](《操作系统》.assets/image-20210905215332873.png)

不同的调度顺序，周转时间会有变化！因为周转时间包括了等待时间。 

![image-20210905215427638](《操作系统》.assets/image-20210905215427638.png)

![image-20210905215501094](《操作系统》.assets/image-20210905215501094.png)

![image-20210905215611505](《操作系统》.assets/image-20210905215611505.png)

![image-20210905215728942](《操作系统》.assets/image-20210905215728942.png)

https://www.bilibili.com/video/BV1wq4y1M7qf?p=50

